{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, getApps, cert, App } from 'firebase-admin/app'\r\nimport { getAuth } from 'firebase-admin/auth'\r\nimport { getFirestore } from 'firebase-admin/firestore'\r\nimport { getStorage } from 'firebase-admin/storage'\r\n\r\nlet adminApp: App | null = null\r\nlet adminAuth: ReturnType<typeof getAuth> | null = null\r\nlet adminDb: ReturnType<typeof getFirestore> | null = null\r\nlet adminStorage: ReturnType<typeof getStorage> | null = null\r\n\r\nexport function getAdminApp(): App {\r\n  if (adminApp) {\r\n    return adminApp\r\n  }\r\n\r\n  // Check if already initialized\r\n  const existingApps = getApps()\r\n  if (existingApps.length > 0) {\r\n    adminApp = existingApps[0]\r\n    return adminApp\r\n  }\r\n\r\n  // Initialize with service account or default credentials\r\n  try {\r\n    let serviceAccount: any = undefined\r\n\r\n    // Option 1: Check for environment variable (for Vercel/production)\r\n    if (process.env.FIREBASE_SERVICE_ACCOUNT_KEY) {\r\n      try {\r\n        serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT_KEY)\r\n      } catch (e) {\r\n        console.warn('[Admin] Failed to parse FIREBASE_SERVICE_ACCOUNT_KEY from env')\r\n      }\r\n    }\r\n\r\n    // Option 2: Check for local service account file (for local development)\r\n    if (!serviceAccount && typeof window === 'undefined') {\r\n      try {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        \r\n        // Try to find service account file in project root\r\n        const possiblePaths = [\r\n          path.join(process.cwd(), 'whisplyy-firebase-adminsdk-fbsvc-51b5120366.json'),\r\n          path.join(process.cwd(), 'serviceAccountKey.json'),\r\n          path.join(process.cwd(), 'firebase-adminsdk.json'),\r\n        ]\r\n\r\n        for (const filePath of possiblePaths) {\r\n          if (fs.existsSync(filePath)) {\r\n            const fileContent = fs.readFileSync(filePath, 'utf8')\r\n            serviceAccount = JSON.parse(fileContent)\r\n            console.log('[Admin] Loaded service account from:', filePath)\r\n            break\r\n          }\r\n        }\r\n      } catch (e) {\r\n        // File not found or error reading - will use default credentials\r\n        console.warn('[Admin] Could not load service account file, using default credentials')\r\n      }\r\n    }\r\n\r\n    if (serviceAccount) {\r\n      adminApp = initializeApp({\r\n        credential: cert(serviceAccount),\r\n        projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || serviceAccount.project_id,\r\n        storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\r\n      })\r\n      console.log('[Admin] Firebase Admin initialized with service account')\r\n    } else {\r\n      // Use default credentials (for local development with gcloud CLI)\r\n      adminApp = initializeApp({\r\n        projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\r\n        storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\r\n      })\r\n      console.log('[Admin] Firebase Admin initialized with default credentials')\r\n    }\r\n\r\n    return adminApp\r\n  } catch (error) {\r\n    console.error('[Admin] Error initializing Firebase Admin:', error)\r\n    throw new Error('Failed to initialize Firebase Admin')\r\n  }\r\n}\r\n\r\nexport function getAdminAuth() {\r\n  if (!adminAuth) {\r\n    const app = getAdminApp()\r\n    adminAuth = getAuth(app)\r\n  }\r\n  return adminAuth\r\n}\r\n\r\nexport function getAdminDb() {\r\n  if (!adminDb) {\r\n    const app = getAdminApp()\r\n    adminDb = getFirestore(app)\r\n  }\r\n  return adminDb\r\n}\r\n\r\nexport function getAdminStorage() {\r\n  if (!adminStorage) {\r\n    const app = getAdminApp()\r\n    adminStorage = getStorage(app)\r\n  }\r\n  return adminStorage\r\n}\r\n\r\n// Helper to get user's custom claims (role, etc.)\r\nexport async function getUserClaims(uid: string) {\r\n  try {\r\n    const auth = getAdminAuth()\r\n    const user = await auth.getUser(uid)\r\n    return user.customClaims || {}\r\n  } catch (error) {\r\n    console.error('[Admin] Error getting user claims:', error)\r\n    return {}\r\n  }\r\n}\r\n\r\n// Helper to check if user is admin\r\nexport async function isAdmin(uid: string): Promise<boolean> {\r\n  try {\r\n    const claims = await getUserClaims(uid)\r\n    return claims.admin === true\r\n  } catch (error) {\r\n    console.error('[Admin] Error checking admin status:', error)\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Check if a user is shadowbanned\r\n * @param userId The user ID to check\r\n * @returns Promise<boolean> True if user is shadowbanned, false otherwise\r\n */\r\nexport async function isShadowbanned(userId: string): Promise<boolean> {\r\n  try {\r\n    const db = getAdminDb()\r\n    const userDoc = await db.collection('users').doc(userId).get()\r\n    \r\n    if (!userDoc.exists) {\r\n      return false\r\n    }\r\n\r\n    const userData = userDoc.data()\r\n    return userData?.status === 'shadowbanned'\r\n  } catch (error) {\r\n    console.error('[Admin] Error checking shadowban status:', error)\r\n    return false\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 214, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/app/actions/feed.ts"],"sourcesContent":["'use server'\r\n\r\nimport { getAdminDb } from '@/lib/firebase-admin'\r\n\r\n/**\r\n * Convert Firestore Timestamp objects to plain JavaScript values\r\n * This is necessary because Timestamps can't be serialized when passing from server to client\r\n */\r\nfunction serializeTimestamp(value: any): any {\r\n  // Check if it's a Firestore Timestamp\r\n  if (value && typeof value === 'object' && 'toDate' in value && typeof value.toDate === 'function') {\r\n    return value.toDate().toISOString()\r\n  }\r\n  // Check if it's a Timestamp-like object with _seconds\r\n  if (value && typeof value === 'object' && '_seconds' in value) {\r\n    const seconds = value._seconds || 0\r\n    const nanoseconds = value._nanoseconds || 0\r\n    return new Date(seconds * 1000 + nanoseconds / 1000000).toISOString()\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Recursively serialize all Timestamp objects in a data object\r\n */\r\nfunction serializePostData(data: any): any {\r\n  if (data === null || data === undefined) {\r\n    return data\r\n  }\r\n  \r\n  if (Array.isArray(data)) {\r\n    return data.map(item => serializePostData(item))\r\n  }\r\n  \r\n  if (typeof data === 'object') {\r\n    const serialized: any = {}\r\n    for (const [key, value] of Object.entries(data)) {\r\n      // Special handling for timestamp fields\r\n      if (key === 'createdAt' || key === 'updatedAt') {\r\n        serialized[key] = serializeTimestamp(value)\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        serialized[key] = serializePostData(value)\r\n      } else {\r\n        serialized[key] = value\r\n      }\r\n    }\r\n    return serialized\r\n  }\r\n  \r\n  return data\r\n}\r\n\r\n/**\r\n * Get feed posts (filtering out shadowbanned users and hidden/deleted posts)\r\n * Supports genre filtering\r\n */\r\nexport async function getFeedPosts(\r\n  limitCount: number = 20,\r\n  lastPostId?: string,\r\n  genre?: string\r\n) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Get all users and identify shadowbanned ones\r\n    // Users without a status field or with status 'active' are considered active\r\n    const allUsersSnapshot = await db.collection('users').get()\r\n    const shadowbannedUserIds = new Set(\r\n      allUsersSnapshot.docs\r\n        .filter(doc => {\r\n          const userData = doc.data()\r\n          return userData.status === 'shadowbanned'\r\n        })\r\n        .map(doc => doc.id)\r\n    )\r\n    \r\n    // Build query - query all posts ordered by createdAt\r\n    // We'll filter by genre and status in memory to avoid index requirements\r\n    let query: any = db.collection('posts')\r\n      .orderBy('createdAt', 'desc')\r\n      .limit(limitCount * 3) // Get more posts since we'll filter some out\r\n    \r\n    // If pagination cursor provided\r\n    if (lastPostId) {\r\n      const lastPostDoc = await db.collection('posts').doc(lastPostId).get()\r\n      if (lastPostDoc.exists) {\r\n        query = query.startAfter(lastPostDoc)\r\n      }\r\n    }\r\n    \r\n    let posts: any[] = []\r\n    try {\r\n      const snapshot = await query.get()\r\n      posts = snapshot.docs.map((doc: any) => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      }))\r\n    } catch (queryError: any) {\r\n      // If query fails (e.g., missing index), try a simpler query and sort in memory\r\n      console.warn('[Server] Query with orderBy failed, trying without orderBy:', queryError.message)\r\n      let fallbackQuery: any = db.collection('posts').limit(limitCount * 5)\r\n      const fallbackSnapshot = await fallbackQuery.get()\r\n      \r\n      posts = fallbackSnapshot.docs.map((doc: any) => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      }))\r\n      \r\n      // Sort in memory by createdAt (descending)\r\n      posts.sort((a: any, b: any) => {\r\n        const aTime = a.createdAt?.toMillis?.() || a.createdAt?._seconds || 0\r\n        const bTime = b.createdAt?.toMillis?.() || b.createdAt?._seconds || 0\r\n        return bTime - aTime // Descending order\r\n      })\r\n    }\r\n    \r\n    // Filter out shadowbanned users, inactive posts, and apply genre filter\r\n    const filteredPosts = posts\r\n      .filter((post: any) => {\r\n        // Exclude posts from shadowbanned users\r\n        if (shadowbannedUserIds.has(post.userId)) {\r\n          return false\r\n        }\r\n        \r\n        // Include posts with status 'active' or no status field (backward compatibility)\r\n        // Exclude posts with other statuses like 'deleted', 'hidden', etc.\r\n        if (post.status && post.status !== 'active') {\r\n          return false\r\n        }\r\n        \r\n        // Apply genre filter if specified\r\n        if (genre && genre !== 'All' && post.genre !== genre) {\r\n          return false\r\n        }\r\n        \r\n        return true\r\n      })\r\n      .slice(0, limitCount) // Limit to requested amount after filtering\r\n    \r\n    // Serialize all posts to convert Timestamps to plain values\r\n    return filteredPosts.map(post => serializePostData(post))\r\n  } catch (error: any) {\r\n    console.error('[Server] Error getting feed posts:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Get user posts (for profile page)\r\n */\r\nexport async function getUserPosts(userId: string) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    const snapshot = await db.collection('posts')\r\n      .where('userId', '==', userId)\r\n      .where('status', '==', 'active')\r\n      .orderBy('createdAt', 'desc')\r\n      .get()\r\n    \r\n    const posts = snapshot.docs.map(doc => ({\r\n      id: doc.id,\r\n      ...doc.data(),\r\n    }))\r\n    \r\n    // Serialize all posts to convert Timestamps to plain values\r\n    return posts.map(post => serializePostData(post))\r\n  } catch (error: any) {\r\n    console.error('[Server] Error getting user posts:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user has liked a post\r\n */\r\nexport async function checkUserLiked(userId: string, postId: string): Promise<boolean> {\r\n  try {\r\n    const db = getAdminDb()\r\n    const likeDoc = await db.collection('posts')\r\n      .doc(postId)\r\n      .collection('likes')\r\n      .doc(userId)\r\n      .get()\r\n    \r\n    return likeDoc.exists\r\n  } catch (error: any) {\r\n    console.error('[Server] Error checking like:', error)\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Get user's liked posts\r\n */\r\nexport async function getUserLikedPosts(userId: string): Promise<Set<string>> {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Get all posts user has liked\r\n    // Note: This is expensive, so we'll optimize by getting likes from user's subcollection\r\n    // But for now, we'll use a different approach - check likes on each post\r\n    \r\n    // Actually, we should store likes in posts/{postId}/likes/{userId}\r\n    // So we need to query all posts and check their likes subcollections\r\n    // This is not efficient, but for MVP it's acceptable\r\n    \r\n    // Better approach: Store user's likes in a separate collection or use client-side caching\r\n    // For now, return empty set and let client handle it\r\n    return new Set()\r\n  } catch (error: any) {\r\n    console.error('[Server] Error getting user liked posts:', error)\r\n    return new Set()\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 474, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/lib/firebase.ts"],"sourcesContent":["import { initializeApp, FirebaseApp } from 'firebase/app'\nimport { Auth, getAuth } from 'firebase/auth'\nimport { Firestore, getFirestore } from 'firebase/firestore'\nimport { FirebaseStorage, getStorage } from 'firebase/storage'\nimport { GoogleAuthProvider } from 'firebase/auth'\n\nconst firebaseConfig = {\n  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY || \"AIzaSyACBv7agfDq3yMs9qdnFQbsnkjmZjNzPWE\",\n  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || \"whisplyy.firebaseapp.com\",\n  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || \"whisplyy\",\n  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || \"whisplyy.appspot.com\",\n  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || \"983464337272\",\n  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID || \"1:983464337272:web:23bf268b6901c686b0328d\",\n}\n\nlet app: FirebaseApp | null = null\nlet auth: Auth | null = null\nlet db: Firestore | null = null\nlet storage: FirebaseStorage | null = null\nlet isInitialized = false\n\n// Initialize Firebase only on client side\nconst initializeFirebase = () => {\n  if (typeof window === 'undefined') return false\n  if (isInitialized) return true\n\n  try {\n    if (!app) {\n      app = initializeApp(firebaseConfig)\n    }\n    if (!auth) {\n      auth = getAuth(app)\n    }\n    if (!db) {\n      db = getFirestore(app)\n    }\n    if (!storage) {\n      storage = getStorage(app)\n    }\n    isInitialized = true\n    console.log('[v0] Firebase initialized successfully')\n    return true\n  } catch (error: any) {\n    console.error('[v0] Firebase initialization error:', error.message)\n    isInitialized = false\n    return false\n  }\n}\n\n// Lazy getters that ensure initialization\nexport const getAppInstance = (): FirebaseApp | null => {\n  if (!app || !isInitialized) {\n    const initialized = initializeFirebase()\n    if (!initialized) return null\n  }\n  return app\n}\n\nexport const getAuthInstance = (): Auth | null => {\n  if (!auth) {\n    initializeFirebase()\n  }\n  return auth\n}\n\nexport const getDbInstance = (): Firestore | null => {\n  if (!db) {\n    initializeFirebase()\n  }\n  return db\n}\n\nexport const getStorageInstance = (): FirebaseStorage | null => {\n  if (!storage) {\n    initializeFirebase()\n  }\n  return storage\n}\n\nexport { storage as firebaseStorage }\n\n// Lazy provider initialization\nlet googleProviderInstance: GoogleAuthProvider | null = null\n\nexport const getGoogleProvider = (): GoogleAuthProvider => {\n  if (!googleProviderInstance) {\n    try {\n      googleProviderInstance = new GoogleAuthProvider()\n      // Add any additional scopes you need\n      googleProviderInstance.addScope('profile')\n      googleProviderInstance.addScope('email')\n      // Set the authentication method to 'popup' for better mobile support\n      googleProviderInstance.setCustomParameters({\n        prompt: 'select_account',\n      })\n    } catch (error) {\n      console.error('[v0] Error creating Google provider:', error)\n      throw new Error('Failed to initialize Google Sign-In. Please try again later.')\n    }\n  }\n  return googleProviderInstance\n}\n\n// Status check\nexport const isFirebaseReady = (): boolean => {\n  if (typeof window === 'undefined') return false\n  if (!isInitialized) {\n    return initializeFirebase()\n  }\n  return !!app && !!auth && !!db && !!storage\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,MAAM,iBAAiB;IACrB,QAAQ,+EAA4C;IACpD,YAAY,gEAAgD;IAC5D,WAAW,gDAA+C;IAC1D,eAAe,4DAAmD;IAClE,mBAAmB,oDAAwD;IAC3E,OAAO,iFAA2C;AACpD;AAEA,IAAI,MAA0B;AAC9B,IAAI,OAAoB;AACxB,IAAI,KAAuB;AAC3B,IAAI,UAAkC;AACtC,IAAI,gBAAgB;AAEpB,0CAA0C;AAC1C,MAAM,qBAAqB;IACzB,wCAAmC,OAAO;;;AAwB5C;AAGO,MAAM,iBAAiB;IAC5B,IAAI,CAAC,OAAO,CAAC,eAAe;QAC1B,MAAM,cAAc;QACpB,IAAI,CAAC,aAAa,OAAO;IAC3B;IACA,OAAO;AACT;AAEO,MAAM,kBAAkB;IAC7B,IAAI,CAAC,MAAM;QACT;IACF;IACA,OAAO;AACT;AAEO,MAAM,gBAAgB;IAC3B,IAAI,CAAC,IAAI;QACP;IACF;IACA,OAAO;AACT;AAEO,MAAM,qBAAqB;IAChC,IAAI,CAAC,SAAS;QACZ;IACF;IACA,OAAO;AACT;;AAIA,+BAA+B;AAC/B,IAAI,yBAAoD;AAEjD,MAAM,oBAAoB;IAC/B,IAAI,CAAC,wBAAwB;QAC3B,IAAI;YACF,yBAAyB,IAAI,4UAAkB;YAC/C,qCAAqC;YACrC,uBAAuB,QAAQ,CAAC;YAChC,uBAAuB,QAAQ,CAAC;YAChC,qEAAqE;YACrE,uBAAuB,mBAAmB,CAAC;gBACzC,QAAQ;YACV;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wCAAwC;YACtD,MAAM,IAAI,MAAM;QAClB;IACF;IACA,OAAO;AACT;AAGO,MAAM,kBAAkB;IAC7B,wCAAmC,OAAO;;;AAK5C"}},
    {"offset": {"line": 574, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/lib/waveform-generator.ts"],"sourcesContent":["/**\r\n * Generate waveform data from audio buffer\r\n * Returns array of peak values normalized to 0-1 range\r\n */\r\nexport async function generateWaveform(\r\n  audioBuffer: ArrayBuffer,\r\n  samples: number = 100\r\n): Promise<number[]> {\r\n  try {\r\n    const audioContext = new AudioContext()\r\n    const decodedData = await audioContext.decodeAudioData(audioBuffer)\r\n    const channelData = decodedData.getChannelData(0) // Use first channel\r\n    const blockSize = Math.floor(channelData.length / samples)\r\n    const waveform: number[] = []\r\n\r\n    for (let i = 0; i < samples; i++) {\r\n      let sum = 0\r\n      const start = i * blockSize\r\n      const end = Math.min(start + blockSize, channelData.length)\r\n\r\n      for (let j = start; j < end; j++) {\r\n        sum += Math.abs(channelData[j])\r\n      }\r\n\r\n      const average = sum / (end - start)\r\n      // Normalize to 0-1 range\r\n      waveform.push(Math.min(average * 2, 1))\r\n    }\r\n\r\n    return waveform\r\n  } catch (error) {\r\n    console.error('[Waveform] Error generating waveform:', error)\r\n    // Return flat waveform on error\r\n    return new Array(samples).fill(0.1)\r\n  }\r\n}\r\n\r\n/**\r\n * Generate waveform from Blob (audio file)\r\n */\r\nexport async function generateWaveformFromBlob(\r\n  blob: Blob,\r\n  samples: number = 100\r\n): Promise<number[]> {\r\n  const arrayBuffer = await blob.arrayBuffer()\r\n  return generateWaveform(arrayBuffer, samples)\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AACM,eAAe,iBACpB,WAAwB,EACxB,UAAkB,GAAG;IAErB,IAAI;QACF,MAAM,eAAe,IAAI;QACzB,MAAM,cAAc,MAAM,aAAa,eAAe,CAAC;QACvD,MAAM,cAAc,YAAY,cAAc,CAAC,GAAG,oBAAoB;;QACtE,MAAM,YAAY,KAAK,KAAK,CAAC,YAAY,MAAM,GAAG;QAClD,MAAM,WAAqB,EAAE;QAE7B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,IAAK;YAChC,IAAI,MAAM;YACV,MAAM,QAAQ,IAAI;YAClB,MAAM,MAAM,KAAK,GAAG,CAAC,QAAQ,WAAW,YAAY,MAAM;YAE1D,IAAK,IAAI,IAAI,OAAO,IAAI,KAAK,IAAK;gBAChC,OAAO,KAAK,GAAG,CAAC,WAAW,CAAC,EAAE;YAChC;YAEA,MAAM,UAAU,MAAM,CAAC,MAAM,KAAK;YAClC,yBAAyB;YACzB,SAAS,IAAI,CAAC,KAAK,GAAG,CAAC,UAAU,GAAG;QACtC;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,yCAAyC;QACvD,gCAAgC;QAChC,OAAO,IAAI,MAAM,SAAS,IAAI,CAAC;IACjC;AACF;AAKO,eAAe,yBACpB,IAAU,EACV,UAAkB,GAAG;IAErB,MAAM,cAAc,MAAM,KAAK,WAAW;IAC1C,OAAO,iBAAiB,aAAa;AACvC"}},
    {"offset": {"line": 619, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/app/actions/posts.ts"],"sourcesContent":["'use server'\r\n\r\nimport { getAuthInstance } from '@/lib/firebase'\r\nimport { getAdminDb, getAdminAuth, isAdmin } from '@/lib/firebase-admin'\r\nimport { getStorageInstance } from '@/lib/firebase'\r\nimport { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage'\r\nimport { generateWaveformFromBlob } from '@/lib/waveform-generator'\r\nimport { Timestamp } from 'firebase-admin/firestore'\r\n\r\ninterface CreatePostParams {\r\n  type: 'text' | 'voice'\r\n  content?: string | null\r\n  mediaBlob?: Blob | null\r\n  mediaMimeType?: string | null\r\n}\r\n\r\ninterface EditPostParams {\r\n  postId: string\r\n  content?: string\r\n  text?: string\r\n  genre?: string\r\n  modulationType?: 'original' | 'deep' | 'robot' | 'whisper'\r\n  mediaBlob?: Blob // For re-processing voice with new modulation\r\n}\r\n\r\n/**\r\n * Rate limiting: Check if user posted within last 2 minutes\r\n */\r\nasync function checkRateLimit(userId: string): Promise<void> {\r\n  const db = getAdminDb()\r\n  const postsRef = db.collection('posts')\r\n  \r\n  const twoMinutesAgo = Timestamp.fromMillis(Date.now() - 2 * 60 * 1000)\r\n  const recentPosts = await postsRef\r\n    .where('userId', '==', userId)\r\n    .where('createdAt', '>', twoMinutesAgo)\r\n    .limit(1)\r\n    .get()\r\n\r\n  if (!recentPosts.empty) {\r\n    throw new Error('Rate limit: Please wait 2 minutes between posts')\r\n  }\r\n}\r\n\r\n/**\r\n * Get user data with denormalized fields\r\n * Creates a default user document if it doesn't exist\r\n */\r\nasync function getUserData(userId: string) {\r\n  const db = getAdminDb()\r\n  const userDoc = await db.collection('users').doc(userId).get()\r\n  \r\n  if (!userDoc.exists) {\r\n    // Create a default user document if it doesn't exist\r\n    // This can happen if user authenticated but document creation failed\r\n    const defaultUserData = {\r\n      uid: userId,\r\n      username: 'Anonymous',\r\n      role: 'user',\r\n      status: 'active',\r\n      avatarUrl: '',\r\n      bio: '',\r\n      createdAt: Timestamp.now(),\r\n      updatedAt: Timestamp.now(),\r\n    }\r\n    \r\n    await db.collection('users').doc(userId).set(defaultUserData)\r\n    \r\n    return {\r\n      username: 'Anonymous',\r\n      avatarUrl: '',\r\n    }\r\n  }\r\n\r\n  const userData = userDoc.data()!\r\n  // Handle both old format (avatar) and new format (avatarUrl)\r\n  const avatarUrl = userData.avatarUrl || userData.avatar || ''\r\n  \r\n  return {\r\n    username: userData.username || 'Anonymous',\r\n    avatarUrl: avatarUrl,\r\n  }\r\n}\r\n\r\n/**\r\n * Check if user is shadowbanned\r\n */\r\nasync function isShadowbanned(userId: string): Promise<boolean> {\r\n  const db = getAdminDb()\r\n  const userDoc = await db.collection('users').doc(userId).get()\r\n  \r\n  if (!userDoc.exists) {\r\n    return false\r\n  }\r\n\r\n  const userData = userDoc.data()!\r\n  return userData.status === 'shadowbanned'\r\n}\r\n\r\n/**\r\n * Create a new post (text or voice)\r\n */\r\nexport async function createPost(params: CreatePostParams) {\r\n  try {\r\n    // Get auth token from request\r\n    // Note: In Next.js Server Actions, we need to pass the auth token\r\n    // For now, we'll use a workaround with client-side auth\r\n    // In production, use cookies or headers to pass the token\r\n    \r\n    const db = getAdminDb()\r\n    \r\n    // Validate input\r\n    if (params.type === 'text' && !params.content?.trim()) {\r\n      throw new Error('Text content is required')\r\n    }\r\n    \r\n    if (params.type === 'voice') {\r\n      if (!params.mediaBlob) {\r\n        throw new Error('Voice recording is required')\r\n      }\r\n      \r\n      // Validate duration (60 seconds max)\r\n      // We'll check this on the client side, but validate file size here\r\n      if (params.mediaBlob.size > 5 * 1024 * 1024) {\r\n        throw new Error('Voice file must be less than 5MB')\r\n      }\r\n    }\r\n\r\n    // Note: In a real implementation, you'd get userId from the auth token\r\n    // For now, we'll need to pass it from the client\r\n    // This is a limitation - we'll need to refactor auth context\r\n    \r\n    throw new Error('createPost: Auth token required - needs refactoring')\r\n  } catch (error: any) {\r\n    console.error('[Server] Error creating post:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\ninterface CreatePostWithAuthParams extends CreatePostParams {\r\n  mediaDuration?: number // Duration in seconds (required for voice posts)\r\n  genre?: string // Genre (required for all posts)\r\n  modulationType?: 'original' | 'deep' | 'robot' | 'whisper' // Voice modulation type\r\n}\r\n\r\n/**\r\n * Create post with userId (called from client with auth)\r\n * This is a temporary solution until we implement proper token passing\r\n */\r\nexport async function createPostWithAuth(\r\n  userId: string,\r\n  params: CreatePostWithAuthParams\r\n) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Check rate limit\r\n    await checkRateLimit(userId)\r\n    \r\n    // Check if user is shadowbanned\r\n    const shadowbanned = await isShadowbanned(userId)\r\n    if (shadowbanned) {\r\n      // Shadowbanned users can post, but posts won't appear to others\r\n      // We'll handle this in the feed query\r\n    }\r\n    \r\n    // Get user data for denormalization\r\n    const userData = await getUserData(userId)\r\n    \r\n    // Validate input\r\n    if (!params.genre) {\r\n      throw new Error('Genre is required for all posts')\r\n    }\r\n    \r\n    if (params.type === 'text' && !params.content?.trim()) {\r\n      throw new Error('Text content is required')\r\n    }\r\n    \r\n    if (params.type === 'voice') {\r\n      if (!params.mediaBlob) {\r\n        throw new Error('Voice recording is required')\r\n      }\r\n      \r\n      if (params.mediaBlob.size > 5 * 1024 * 1024) {\r\n        throw new Error('Voice file must be less than 5MB')\r\n      }\r\n      \r\n      if (!params.mediaDuration || params.mediaDuration > 60) {\r\n        throw new Error('Voice recording must be 60 seconds or less')\r\n      }\r\n      \r\n      if (!params.modulationType) {\r\n        throw new Error('Modulation type is required for voice posts')\r\n      }\r\n    }\r\n\r\n    const now = Timestamp.now()\r\n    \r\n    // Get genre color\r\n    const genreColors: Record<string, string> = {\r\n      'Confession': '#FF6B6B',\r\n      'Motivation': '#6BCB77',\r\n      'Love / Heartbreak': '#A66CFF',\r\n      'Dark Thoughts': '#FF4C4C',\r\n      'Friendship': '#4D96FF',\r\n      'Life Advice': '#FFD93D',\r\n      'Humor': '#FF9F1C',\r\n      'Storytime': '#845EC2',\r\n    }\r\n    \r\n    const postData: any = {\r\n      id: '', // Will be set when creating document\r\n      userId,\r\n      genre: params.genre,\r\n      genreColor: genreColors[params.genre] || '#8b5cf6',\r\n      modulationType: params.type === 'voice' ? (params.modulationType || 'original') : null,\r\n      audioUrl: null,\r\n      text: params.type === 'text' ? params.content : null,\r\n      duration: params.type === 'voice' ? (params.mediaDuration || 0) : 0,\r\n      reported: false,\r\n      reports: [],\r\n      authorUsername: userData.username,\r\n      authorAvatarUrl: userData.avatarUrl,\r\n      type: params.type,\r\n      content: params.type === 'text' ? params.content : null, // Keep for backward compatibility\r\n      mediaUrl: null,\r\n      mediaDuration: params.type === 'voice' ? params.mediaDuration : null,\r\n      mediaMimeType: null,\r\n      waveform: null,\r\n      status: 'active',\r\n      likesCount: 0,\r\n      commentsCount: 0,\r\n      createdAt: now,\r\n      updatedAt: now,\r\n      isEdited: false,\r\n    }\r\n\r\n    // Handle voice post\r\n    if (params.type === 'voice' && params.mediaBlob) {\r\n      // Upload audio file\r\n      const storage = getStorageInstance()\r\n      if (!storage) {\r\n        throw new Error('Storage not initialized')\r\n      }\r\n\r\n      const postId = db.collection('posts').doc().id\r\n      const storagePath = `voice-posts/${userId}/${postId}.webm`\r\n      const storageRef = ref(storage, storagePath)\r\n      \r\n      await uploadBytes(storageRef, params.mediaBlob)\r\n      const mediaUrl = await getDownloadURL(storageRef)\r\n      \r\n      // Generate waveform\r\n      const waveform = await generateWaveformFromBlob(params.mediaBlob, 100)\r\n      \r\n      postData.mediaUrl = mediaUrl\r\n      postData.audioUrl = mediaUrl // Also set audioUrl for new data model\r\n      postData.mediaDuration = params.mediaDuration\r\n      postData.duration = params.mediaDuration // Also set duration for new data model\r\n      postData.mediaMimeType = params.mediaMimeType || 'audio/webm'\r\n      postData.waveform = waveform\r\n      postData.id = postId\r\n      \r\n      // Create post document\r\n      await db.collection('posts').doc(postId).set(postData)\r\n      return { success: true, postId }\r\n    } else {\r\n      // Text post\r\n      const postRef = db.collection('posts').doc()\r\n      postData.id = postRef.id\r\n      await postRef.set(postData)\r\n      return { success: true, postId: postRef.id }\r\n    }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error creating post:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Edit post (text, genre, and voice modulation can be updated)\r\n */\r\nexport async function editPost(userId: string, params: EditPostParams) {\r\n  try {\r\n    const db = getAdminDb()\r\n    const postRef = db.collection('posts').doc(params.postId)\r\n    const postDoc = await postRef.get()\r\n    \r\n    if (!postDoc.exists) {\r\n      throw new Error('Post not found')\r\n    }\r\n    \r\n    const postData = postDoc.data()!\r\n    \r\n    // Verify ownership\r\n    if (postData.userId !== userId) {\r\n      throw new Error('Unauthorized: You can only edit your own posts')\r\n    }\r\n    \r\n    const updateData: any = {\r\n      updatedAt: Timestamp.now(),\r\n      isEdited: true,\r\n    }\r\n    \r\n    // Update text content (for text posts or voice captions)\r\n    if (params.text !== undefined || params.content !== undefined) {\r\n      const textContent = params.text || params.content\r\n      if (!textContent?.trim()) {\r\n        throw new Error('Content cannot be empty')\r\n      }\r\n      updateData.text = textContent\r\n      updateData.content = textContent // Keep for backward compatibility\r\n    }\r\n    \r\n    // Update genre\r\n    if (params.genre) {\r\n      const genreColors: Record<string, string> = {\r\n        'Confession': '#FF6B6B',\r\n        'Motivation': '#6BCB77',\r\n        'Love / Heartbreak': '#A66CFF',\r\n        'Dark Thoughts': '#FF4C4C',\r\n        'Friendship': '#4D96FF',\r\n        'Life Advice': '#FFD93D',\r\n        'Humor': '#FF9F1C',\r\n        'Storytime': '#845EC2',\r\n      }\r\n      updateData.genre = params.genre\r\n      updateData.genreColor = genreColors[params.genre] || '#8b5cf6'\r\n    }\r\n    \r\n    // Update modulation for voice posts (requires re-processing)\r\n    if (params.modulationType && postData.type === 'voice') {\r\n      if (params.mediaBlob) {\r\n        // Re-process audio with new modulation\r\n        const storage = getStorageInstance()\r\n        if (!storage) {\r\n          throw new Error('Storage not initialized')\r\n        }\r\n        \r\n        const storagePath = `voice-posts/${userId}/${params.postId}.webm`\r\n        const storageRef = ref(storage, storagePath)\r\n        \r\n        await uploadBytes(storageRef, params.mediaBlob)\r\n        const audioUrl = await getDownloadURL(storageRef)\r\n        \r\n        // Generate new waveform\r\n        const waveform = await generateWaveformFromBlob(params.mediaBlob, 100)\r\n        \r\n        updateData.audioUrl = audioUrl\r\n        updateData.mediaUrl = audioUrl // Keep for backward compatibility\r\n        updateData.waveform = waveform\r\n      }\r\n      updateData.modulationType = params.modulationType\r\n    }\r\n    \r\n    // Update post\r\n    await postRef.update(updateData)\r\n    \r\n    return { success: true }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error editing post:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Edit text post (backward compatibility)\r\n */\r\nexport async function editTextPost(userId: string, params: EditPostParams) {\r\n  return editPost(userId, { ...params, text: params.content })\r\n}\r\n\r\n/**\r\n * Delete post\r\n */\r\nexport async function deletePost(userId: string, postId: string) {\r\n  try {\r\n    const db = getAdminDb()\r\n    const postRef = db.collection('posts').doc(postId)\r\n    const postDoc = await postRef.get()\r\n    \r\n    if (!postDoc.exists) {\r\n      throw new Error('Post not found')\r\n    }\r\n    \r\n    const postData = postDoc.data()!\r\n    \r\n    // Verify ownership or admin\r\n    const userIsAdmin = await isAdmin(userId)\r\n    if (postData.userId !== userId && !userIsAdmin) {\r\n      throw new Error('Unauthorized')\r\n    }\r\n    \r\n    // Delete audio file from storage if voice post\r\n    if (postData.type === 'voice' && postData.audioUrl) {\r\n      try {\r\n        const storage = getStorageInstance()\r\n        if (storage) {\r\n          // Extract path from URL or use standard path\r\n          const storagePath = `voice-posts/${postData.userId}/${params.postId}.webm`\r\n          const storageRef = ref(storage, storagePath)\r\n          // Note: Firebase Admin SDK needed for delete, but we can mark for deletion\r\n          // For now, we'll rely on Storage rules and manual cleanup\r\n        }\r\n      } catch (storageError) {\r\n        console.error('[Server] Error deleting audio file:', storageError)\r\n        // Continue with post deletion even if storage deletion fails\r\n      }\r\n    }\r\n    \r\n    // Delete post document\r\n    await postRef.delete()\r\n    \r\n    return { success: true }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error deleting post:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 986, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/app/actions/likes.ts"],"sourcesContent":["'use server'\r\n\r\nimport { getAdminDb } from '@/lib/firebase-admin'\r\nimport { Timestamp } from 'firebase-admin/firestore'\r\n\r\n/**\r\n * Toggle like on a post\r\n */\r\nexport async function toggleLike(userId: string, postId: string) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Check if already liked\r\n    const likeRef = db.collection('posts').doc(postId).collection('likes').doc(userId)\r\n    const likeDoc = await likeRef.get()\r\n    \r\n    const postRef = db.collection('posts').doc(postId)\r\n    const postDoc = await postRef.get()\r\n    \r\n    if (!postDoc.exists) {\r\n      throw new Error('Post not found')\r\n    }\r\n    \r\n    const isLiked = likeDoc.exists\r\n    \r\n    if (isLiked) {\r\n      // Unlike: remove like document and decrement count\r\n      await likeRef.delete()\r\n      await postRef.update({\r\n        likesCount: (postDoc.data()!.likesCount || 0) - 1,\r\n      })\r\n      return { success: true, liked: false }\r\n    } else {\r\n      // Like: add like document and increment count\r\n      await likeRef.set({\r\n        createdAt: Timestamp.now(),\r\n      })\r\n      await postRef.update({\r\n        likesCount: (postDoc.data()!.likesCount || 0) + 1,\r\n      })\r\n      return { success: true, liked: true }\r\n    }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error toggling like:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;;;;;;AAKO,eAAe,WAAW,MAAc,EAAE,MAAc;IAC7D,IAAI;QACF,MAAM,KAAK,IAAA,sLAAU;QAErB,yBAAyB;QACzB,MAAM,UAAU,GAAG,UAAU,CAAC,SAAS,GAAG,CAAC,QAAQ,UAAU,CAAC,SAAS,GAAG,CAAC;QAC3E,MAAM,UAAU,MAAM,QAAQ,GAAG;QAEjC,MAAM,UAAU,GAAG,UAAU,CAAC,SAAS,GAAG,CAAC;QAC3C,MAAM,UAAU,MAAM,QAAQ,GAAG;QAEjC,IAAI,CAAC,QAAQ,MAAM,EAAE;YACnB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,UAAU,QAAQ,MAAM;QAE9B,IAAI,SAAS;YACX,mDAAmD;YACnD,MAAM,QAAQ,MAAM;YACpB,MAAM,QAAQ,MAAM,CAAC;gBACnB,YAAY,CAAC,QAAQ,IAAI,GAAI,UAAU,IAAI,CAAC,IAAI;YAClD;YACA,OAAO;gBAAE,SAAS;gBAAM,OAAO;YAAM;QACvC,OAAO;YACL,8CAA8C;YAC9C,MAAM,QAAQ,GAAG,CAAC;gBAChB,WAAW,yKAAS,CAAC,GAAG;YAC1B;YACA,MAAM,QAAQ,MAAM,CAAC;gBACnB,YAAY,CAAC,QAAQ,IAAI,GAAI,UAAU,IAAI,CAAC,IAAI;YAClD;YACA,OAAO;gBAAE,SAAS;gBAAM,OAAO;YAAK;QACtC;IACF,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,MAAM;IACR;AACF;;;IAtCsB;;AAAA,wYAAA"}},
    {"offset": {"line": 1054, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/app/actions/comments.ts"],"sourcesContent":["'use server'\r\n\r\nimport { getAdminDb, isShadowbanned } from '@/lib/firebase-admin'\r\nimport { Timestamp } from 'firebase-admin/firestore'\r\n\r\ninterface AddCommentParams {\r\n  postId: string\r\n  userId: string\r\n  content: string\r\n}\r\n\r\n/**\r\n * Convert Firestore Timestamp objects to plain JavaScript values\r\n * This is necessary because Timestamps can't be serialized when passing from server to client\r\n */\r\nfunction serializeTimestamp(value: any): any {\r\n  // Check if it's a Firestore Timestamp\r\n  if (value && typeof value === 'object' && 'toDate' in value && typeof value.toDate === 'function') {\r\n    return value.toDate().toISOString()\r\n  }\r\n  // Check if it's a Timestamp-like object with _seconds\r\n  if (value && typeof value === 'object' && '_seconds' in value) {\r\n    const seconds = value._seconds || 0\r\n    const nanoseconds = value._nanoseconds || 0\r\n    return new Date(seconds * 1000 + nanoseconds / 1000000).toISOString()\r\n  }\r\n  return value\r\n}\r\n\r\n/**\r\n * Recursively serialize all Timestamp objects in a data object\r\n */\r\nfunction serializeCommentData(data: any): any {\r\n  if (data === null || data === undefined) {\r\n    return data\r\n  }\r\n  \r\n  if (Array.isArray(data)) {\r\n    return data.map(item => serializeCommentData(item))\r\n  }\r\n  \r\n  if (typeof data === 'object') {\r\n    const serialized: any = {}\r\n    for (const [key, value] of Object.entries(data)) {\r\n      // Special handling for timestamp fields\r\n      if (key === 'createdAt' || key === 'updatedAt') {\r\n        serialized[key] = serializeTimestamp(value)\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        serialized[key] = serializeCommentData(value)\r\n      } else {\r\n        serialized[key] = value\r\n      }\r\n    }\r\n    return serialized\r\n  }\r\n  \r\n  return data\r\n}\r\n\r\n/**\r\n * Add comment to a post\r\n */\r\nexport async function addComment(params: AddCommentParams) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Check if user is shadowbanned\r\n    const shadowbanned = await isShadowbanned(params.userId)\r\n    if (shadowbanned) {\r\n      // Shadowbanned users can comment, but comments won't appear to others\r\n      // We'll handle this in the comments query\r\n    }\r\n    \r\n    // Get user data for denormalization\r\n    const userDoc = await db.collection('users').doc(params.userId).get()\r\n    if (!userDoc.exists) {\r\n      throw new Error('User not found')\r\n    }\r\n    \r\n    const userData = userDoc.data()!\r\n    \r\n    // Validate content\r\n    if (!params.content?.trim()) {\r\n      throw new Error('Comment content is required')\r\n    }\r\n    \r\n    // Check if post exists\r\n    const postRef = db.collection('posts').doc(params.postId)\r\n    const postDoc = await postRef.get()\r\n    \r\n    if (!postDoc.exists) {\r\n      throw new Error('Post not found')\r\n    }\r\n    \r\n    const postData = postDoc.data()!\r\n    if (postData.status !== 'active') {\r\n      throw new Error('Cannot comment on this post')\r\n    }\r\n    \r\n    // Add comment to subcollection\r\n    const commentRef = postRef.collection('comments').doc()\r\n    await commentRef.set({\r\n      userId: params.userId,\r\n      authorUsername: userData.username || 'Anonymous',\r\n      authorAvatarUrl: userData.avatarUrl || '',\r\n      content: params.content.trim(),\r\n      createdAt: Timestamp.now(),\r\n      status: 'active',\r\n    })\r\n    \r\n    // Increment comment count\r\n    await postRef.update({\r\n      commentsCount: (postData.commentsCount || 0) + 1,\r\n    })\r\n    \r\n    return { success: true, commentId: commentRef.id }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error adding comment:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n/**\r\n * Get comments for a post (filtering out shadowbanned users)\r\n */\r\nexport async function getPostComments(postId: string) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Get all users and identify shadowbanned ones\r\n    // Users without a status field or with status 'active' are considered active\r\n    const allUsersSnapshot = await db.collection('users').get()\r\n    const shadowbannedUserIds = new Set(\r\n      allUsersSnapshot.docs\r\n        .filter(doc => {\r\n          const userData = doc.data()\r\n          return userData.status === 'shadowbanned'\r\n        })\r\n        .map(doc => doc.id)\r\n    )\r\n    \r\n    // Get comments\r\n    const commentsSnapshot = await db.collection('posts')\r\n      .doc(postId)\r\n      .collection('comments')\r\n      .where('status', '==', 'active')\r\n      .orderBy('createdAt', 'desc')\r\n      .get()\r\n    \r\n    // Filter out shadowbanned users\r\n    const comments = commentsSnapshot.docs\r\n      .map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n      }))\r\n      .filter((comment: any) => {\r\n        // Only show comments from active (non-shadowbanned) users\r\n        return !shadowbannedUserIds.has(comment.userId)\r\n      })\r\n    \r\n    // Serialize all comments to convert Timestamps to plain values\r\n    return comments.map(comment => serializeCommentData(comment))\r\n  } catch (error: any) {\r\n    console.error('[Server] Error getting comments:', error)\r\n    return []\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1206, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/app/actions/reports.ts"],"sourcesContent":["'use server'\r\n\r\nimport { getAdminDb } from '@/lib/firebase-admin'\r\nimport { Timestamp } from 'firebase-admin/firestore'\r\n\r\n/**\r\n * Report a post\r\n * Appends to reports[] array and sets reported = true\r\n */\r\nexport async function reportPost(postId: string, userId: string, reason: string) {\r\n  try {\r\n    const db = getAdminDb()\r\n    \r\n    // Check if post exists\r\n    const postDoc = await db.collection('posts').doc(postId).get()\r\n    if (!postDoc.exists) {\r\n      throw new Error('Post not found')\r\n    }\r\n    \r\n    const postData = postDoc.data()!\r\n    \r\n    // Check if user already reported this post\r\n    const existingReport = postData.reports?.find(\r\n      (r: any) => r.userId === userId\r\n    )\r\n    \r\n    if (existingReport) {\r\n      throw new Error('You have already reported this post')\r\n    }\r\n    \r\n    // Append to reports array and set reported = true\r\n    const reports = postData.reports || []\r\n    reports.push({\r\n      type: reason,\r\n      userId,\r\n      createdAt: Timestamp.now(),\r\n    })\r\n    \r\n    await db.collection('posts').doc(postId).update({\r\n      reported: true,\r\n      reports,\r\n    })\r\n    \r\n    return { success: true }\r\n  } catch (error: any) {\r\n    console.error('[Server] Error reporting post:', error)\r\n    throw error\r\n  }\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;;;;;;;;;;AAMO,eAAe,WAAW,MAAc,EAAE,MAAc,EAAE,MAAc;IAC7E,IAAI;QACF,MAAM,KAAK,IAAA,sLAAU;QAErB,uBAAuB;QACvB,MAAM,UAAU,MAAM,GAAG,UAAU,CAAC,SAAS,GAAG,CAAC,QAAQ,GAAG;QAC5D,IAAI,CAAC,QAAQ,MAAM,EAAE;YACnB,MAAM,IAAI,MAAM;QAClB;QAEA,MAAM,WAAW,QAAQ,IAAI;QAE7B,2CAA2C;QAC3C,MAAM,iBAAiB,SAAS,OAAO,EAAE,KACvC,CAAC,IAAW,EAAE,MAAM,KAAK;QAG3B,IAAI,gBAAgB;YAClB,MAAM,IAAI,MAAM;QAClB;QAEA,kDAAkD;QAClD,MAAM,UAAU,SAAS,OAAO,IAAI,EAAE;QACtC,QAAQ,IAAI,CAAC;YACX,MAAM;YACN;YACA,WAAW,yKAAS,CAAC,GAAG;QAC1B;QAEA,MAAM,GAAG,UAAU,CAAC,SAAS,GAAG,CAAC,QAAQ,MAAM,CAAC;YAC9C,UAAU;YACV;QACF;QAEA,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,kCAAkC;QAChD,MAAM;IACR;AACF;;;IAvCsB;;AAAA,wYAAA"}},
    {"offset": {"line": 1267, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/hp/Downloads/anonymous-social-platform/.next-internal/server/app/profile/%5Buid%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getUserPosts as '404e2f9d30ac88c6aa4f751cc2e3e34fba950b303b'} from 'ACTIONS_MODULE0'\nexport {deletePost as '6017dcfb18c083f3a87ffc816394aeb0d27e19a962'} from 'ACTIONS_MODULE1'\nexport {toggleLike as '60bf1b3d64d6019825add7bb8b1aed3cc61d5540b5'} from 'ACTIONS_MODULE2'\nexport {getPostComments as '404d910a566286892204be87060f5c27cd920fa2ec'} from 'ACTIONS_MODULE3'\nexport {addComment as '4042c7f6066b206e0590f3129fba0273d94a6411d5'} from 'ACTIONS_MODULE3'\nexport {reportPost as '7084916c377494247151cef281f503624be26e963c'} from 'ACTIONS_MODULE4'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AAEA"}}]
}